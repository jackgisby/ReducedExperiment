% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/factors.R
\name{run_ica}
\alias{run_ica}
\title{Run ICA for a data matrix}
\usage{
run_ica(
  X,
  nc,
  use_stability = FALSE,
  resample = FALSE,
  method = "fast",
  stability_threshold = NULL,
  center_X = TRUE,
  scale_X = FALSE,
  reorient_skewed = TRUE,
  seed = 1,
  scale_components = TRUE,
  scale_reduced = TRUE,
  n_runs = 30,
  BPPARAM = BiocParallel::SerialParam(),
  ...
)
}
\arguments{
\item{X}{A matrix with features as rows and columns as samples.}

\item{nc}{The number of components to be identified. See
\link{ReducedExperiment}\link{estimate_stability} for a method to estimate the
optimal number of components.}

\item{use_stability}{Whether to use a stability-based approach to estimate
factors. See \code{details} for further information}

\item{resample}{If TRUE, a boostrap approach is used to estimating factors.
Else, random initialisation of ICA is employed. Ignored if \code{use_stability}
is FALSE. See \code{details} for further information.}

\item{method}{The ICA method to use. Passed to \link{ica}\link{ica}, the options
are "fast", "imax" or "jade".}

\item{stability_threshold}{A stability threshold for pruning factors. Factors
with a stability below this threshold will be removed. If used, the threshold
can lead to fewer factors being returned than that specified by \code{nc}.}

\item{center_X}{If TRUE, X is centered (i.e., features / rows are transformed
to have a mean of 0) prior to ICA. Generally recommended.}

\item{scale_X}{If TRUE, X is scaled (i.e., features / rows are transformed
to have a standard deviation of 1) before ICA.}

\item{reorient_skewed}{If TRUE, factors are reorientated to ensure that the
loadings of each factor (i.e., the source signal matrix) have positive skew.
Helps ensure that the most influential features for each factor are
positively associated with it.}

\item{seed}{Random seed for stability-based approach.}

\item{scale_components}{If TRUE, the loadings are standardised (to have a mean of 0
and standard deviation of 1).}

\item{scale_reduced}{If TRUE, the reduced data (mixture matrix) are
standardised (to have a mean of 0 and standard deviation of 1).}

\item{n_runs}{The number of times to run ICA. Ignored if \code{use_stability} is
FALSE. See \code{details} for further information.}

\item{BPPARAM}{A class containing parameters for parallel evaluation. Uses
\link[BiocParallel]{SerialParam} by default, running only a single
ICA computation at a time. Ignored if \code{use_stability}
is FALSE. See \code{details} for further information.}

\item{...}{Additional arguments to be passed to
\link{ica}\link{ica}.}
}
\description{
Runs ICA through \link{ica}\link{ica}. X is passed directly to \link{ica}\link{ica},
with rows as features and samples as columns. Generates a source signal
matrix (loadings) with rows as features and columns as factors and a mixture
matrix (reduced data) with samples as rows and columns as factors.
}
\details{
Function performs ICA for a data matrix. If \code{use_stability} is TRUE, then
ICA is performed multiple times with either: i) random initialisation
(default); or ii) bootstrap resampling of the data (if \code{resample} is TRUE).

The stability-based ICA algorithm is similar to the the ICASSO approach
(https://www.cs.helsinki.fi/u/ahyvarin/papers/Himberg03.pd) that is
implemented in the stabilized-ica Python package
(https://github.com/ncaptier/stabilized-ica/tree/master).

Results from this function should be broadly similar to those generated by
stabilized-ica, although they will not be identical. Notable differences
include:
\itemize{
\item{"ICA algorithm"}{Differences in the underlying implementation of
ICA could contribute to changes in the final results.}
\item{"Stability threshold"}{The \code{stability_threshold} argument, if
specified, removes unstable components. Such a threshold is not
used by stabilized-ica.}
\item{"Mixture matrix recovery"}{ICA is generally formulated as
\code{X = MS}, where \code{X} is the input data, \code{M} is the mixture matrix
(reduced data) and \code{S} is the source signal matrix (feature loadings).
The stabilised ICA approach first calculates a source signal matrix
before recovering the mixture matrix. To do this, other implementations,
including that of the stabilized-ica package, multiply \code{X} by the
pseudo-inverse of \code{S}. Such an operation is implemented in the \code{ginv}
function of the \code{MASS} R package. In the development of ReducedExperiment,
we noticed that taking the inverse of \code{S} often failed, particularly when
there were correlated factors. For this reason, we instead formulate the
mixture matrix as \code{M = XS}. After standardisation of \code{M}, both approaches
return near-identical results, given that the matrix inverse was
successfully calculated.}
}

In short, the stability-based algorithm consists of:
i) Running ICA multiple times with either random initialisation or bootstrap
resampling of the input data.
ii) Clustering the resulting factors across all runs based on the
signature matrix.
iii) Calculating intra- (aics) and extra- (aecs) cluster
stability, and defining the final cluster stability as \code{aics - aecs}.
iv) Calculating the cluster centrotype as the factor with the highest
intra-cluster stability.
v) Optionally removing factors below a specified stability threshold
(\code{stability_threshold}).
}
